Given a positive integer, find the largest number that could be generated by swapping only two digits at most once.
Examples: 
 

Input: 2736
Output : 7236
Explanation:
If we swap the number 2 and the number
7 then the generated number would be 
the largest number.

Input : 432
Output : 432
Explanation:
Here, no swap is required. The given
number is already largest.








bruete force Approach>>>>>>>>>>>>>>>

class Solution {
public:
    int maximumSwap(int num) {
           string s = to_string(num);
        int n = s.length(), largest = num;
        
        for(int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++) {
                if(s[i] < s[j]) {
                    swap(s[i], s[j]);
                    largest = max(largest, stoi(s));
                    swap(s[i], s[j]);
                }
            }
        }
        
        return largest;
    
     }
};



efficient approach

class Solution {
public:
    //Time-O(N) 
    //Space-O(1)
    int maximumSwap(int num) {
   ` string s=to_string(num);  
     // 1.Prepare the  digit last occurence  array
    // space-O(10)==O(1)
     int arr[10]={0};
     for(int i=0;i<s.length();i++){
         arr[s[i]-'0']=i;
     }
    //2.Check tha valid condn for swapping
    //if swap is done change it to true
    bool val=false;
    for(int i=0;i<s.length();i++){
        int num=s[i]-'0';
        //3. check for the value b/w 9 to arr[i] exclude arr[i ] bcz these are the possible digit to swap
        for(int j=9;j>num;j--){
            if(arr[j]>i){
                swap(s[arr[j]],s[i]);
                val=true;
                break;
            }   
        }
        if(val)break; 
    }
    int digit=stoi(s);
    return digit;
    }
};


Okay, so the idea here is to work smarter not harder and with some clever thinking along with the STL we can accomplish this.
------------------------------------------------------------------------------------------------------------------------------

Some Upfront Realizations & edge cases:
1. If I am given a single digit number I can just return it since there are no swaps necessary.
2. What if I am already given the max number? You could handle this with a conditional, however, 
the main algorithm is able to handle this anyways so there is no point.

Goal:
1. Again, the goal of this problem is returning the max number possible with 1 single swap. Upon first look, the difficuly comes
from thinking, how the heck do I determine
	the maximum value?
	
Clever thinking is the answer!
1. You have to realize that regardless of the input, you already have indirect access to the maximum number possible. 
All you have to do is
a. convert the input integer to a string
b. sort that string in ascending order (this will yield the smallest number)
c. reverse the sorted string (this will yield descending order)
d. AND BOOM, now you have access too the largest number possible which is the ideal outcome

Main Algorithm:
1. Create a string version of the oringal input 
2. Create a second copy of input transformed into the string
3. Transfrom the copy to the largest number possible via sort() and reverse()
4. Loop through both strings simulataneously (this works as they are both the same length) and once you encounter a mismatch between
    the original string and the ideal string simply swap the character at position jj within the original string with the last instance of the character 
	in the original string that matches the current character at position jj in the ideal string.
5. If you have to make a swap you simply bail out of the for loop, or you may never have to bail out via the continue statement. 
   (The use of continue statement is how the edge case of a maximum input given is handled )
 6. Once you finisih the for-loop processing you simply have to convert your modified original string back to and integer and return the result.

I hope this helps! Happy coding!
----------------------------------------------------------------------------------------------------------------------------------
*/
class Solution {
public:
    int maximumSwap(int num) {
        if (num >= 0 && num < 9) { return num; }
        
        // convert to string
        string s = to_string(num);
        string max_n = to_string(num);
        
        sort(max_n.begin(), max_n.end()); // sort
        reverse(max_n.begin(), max_n.end()); // reverse
        
        for (auto i = 0; i < s.length(); i++) {
            if (s[i] == max_n[i]) { continue; }
            int index = s.find_last_of(max_n[i]);
            swap(s[i], s[index]);
            break;
        }
        stringstream ss(s);
        int value = 0;
        ss >> value;
        return value;
    }
};



